<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IndexedDB Workbench</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/alasql/1.7.6/alasql.min.js" integrity="sha512-3oGKuXSSJmsNW6cgZaywI4yajFh0U5sd+Ap85sZfMCzkgh1DGoKj1jNvZdapfH1uVfxz6GyyHxEwG2NIQPtQOQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <style>
        :root {
            color-scheme: light dark;
            --bg: #f5f5f7;
            --surface: #ffffff;
            --surface-dark: #1f1f24;
            --border: #d0d0d7;
            --border-dark: #2d2d35;
            --accent: #2563eb;
            --accent-dark: #3b82f6;
            --text: #1f2933;
            --text-muted: #52616b;
            --text-dark: #e5e7eb;
            --text-dark-muted: #9ca3af;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            padding: 1rem 2rem;
            background: linear-gradient(135deg, #1e293b 0%, #2563eb 100%);
            color: white;
            box-shadow: 0 10px 30px rgba(37, 99, 235, 0.35);
        }

        header h1 {
            margin: 0;
            font-size: 1.5rem;
            font-weight: 600;
        }

        main {
            flex: 1;
            display: grid;
            grid-template-columns: 320px 1fr;
            gap: 1.5rem;
            padding: 1.5rem 2rem 2rem;
        }

        @media (max-width: 1100px) {
            main {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: var(--surface);
            border-radius: 18px;
            padding: 1.25rem;
            border: 1px solid var(--border);
            box-shadow: 0 20px 40px rgba(15, 23, 42, 0.08);
        }

        .panel h2 {
            margin-top: 0;
            font-size: 1.15rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .panel h3 {
            margin-top: 1.5rem;
            font-size: 1rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-muted);
        }

        label {
            font-weight: 600;
            font-size: 0.85rem;
            display: block;
            margin-bottom: 0.25rem;
        }

        input, select, textarea {
            width: 100%;
            padding: 0.6rem 0.75rem;
            border-radius: 10px;
            border: 1px solid var(--border);
            font-family: inherit;
            font-size: 0.95rem;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.12);
        }

        button {
            appearance: none;
            border: none;
            padding: 0.55rem 0.9rem;
            border-radius: 10px;
            font-family: inherit;
            font-weight: 600;
            font-size: 0.9rem;
            display: inline-flex;
            align-items: center;
            gap: 0.45rem;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        button.primary {
            background: var(--accent);
            color: white;
            box-shadow: 0 10px 20px rgba(37, 99, 235, 0.25);
        }

        button.secondary {
            background: #f1f5f9;
            color: var(--text);
            border: 1px solid var(--border);
        }

        button.danger {
            background: #ef4444;
            color: white;
        }

        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 12px 20px rgba(15, 23, 42, 0.12);
        }

        button:disabled {
            cursor: not-allowed;
            opacity: 0.6;
            transform: none;
            box-shadow: none;
        }

        .actions {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-top: 1rem;
        }

        .db-list, .store-list {
            margin: 0;
            padding: 0;
            list-style: none;
        }

        .db-list li, .store-list li {
            padding: 0.6rem 0.75rem;
            border-radius: 10px;
            margin-bottom: 0.4rem;
            border: 1px solid transparent;
            cursor: pointer;
            background: rgba(148, 163, 184, 0.12);
        }

        .db-list li.active, .store-list li.active {
            border-color: var(--accent);
            background: rgba(37, 99, 235, 0.12);
        }

        .muted {
            color: var(--text-muted);
            font-size: 0.85rem;
        }

        .section {
            margin-bottom: 1.5rem;
        }

        .section:last-child {
            margin-bottom: 0;
        }

        .badge {
            display: inline-flex;
            align-items: center;
            padding: 0.15rem 0.45rem;
            font-size: 0.65rem;
            background: rgba(37, 99, 235, 0.15);
            color: var(--accent);
            border-radius: 999px;
            font-weight: 600;
            margin-left: 0.5rem;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            font-size: 0.9rem;
        }

        th, td {
            text-align: left;
            padding: 0.6rem 0.75rem;
            border-bottom: 1px solid var(--border);
            vertical-align: top;
        }

        th {
            font-weight: 600;
            background: rgba(15, 23, 42, 0.04);
        }

        .table-container {
            overflow: auto;
            max-height: 45vh;
            border-radius: 12px;
            border: 1px solid var(--border);
        }

        .json-block {
            background: rgba(15, 23, 42, 0.04);
            border-radius: 12px;
            padding: 0.75rem;
            font-family: 'SFMono-Regular', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
            font-size: 0.85rem;
            overflow: auto;
        }

        .flex {
            display: flex;
            gap: 0.75rem;
        }

        .flex.vertical {
            flex-direction: column;
        }

        .flex > div {
            flex: 1;
        }

        .toast-container {
            position: fixed;
            top: 1.5rem;
            right: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            z-index: 9999;
        }

        .toast {
            background: #0f172a;
            color: white;
            padding: 0.75rem 1rem;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(15, 23, 42, 0.35);
            min-width: 240px;
            display: flex;
            justify-content: space-between;
            gap: 1rem;
            align-items: center;
            font-size: 0.85rem;
        }

        .toast button {
            background: transparent;
            color: inherit;
            padding: 0;
            box-shadow: none;
        }

        .tooltip {
            position: relative;
            cursor: help;
        }

        .tooltip .tooltip-text {
            visibility: hidden;
            width: 260px;
            background-color: #1f2937;
            color: #fff;
            text-align: left;
            border-radius: 8px;
            padding: 0.6rem 0.75rem;
            position: absolute;
            z-index: 1;
            top: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.2s;
            font-size: 0.75rem;
        }

        .tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        .chip-group {
            display: flex;
            flex-wrap: wrap;
            gap: 0.4rem;
        }

        .chip {
            padding: 0.2rem 0.6rem;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.08);
            font-size: 0.75rem;
        }

        textarea {
            resize: vertical;
        }

        .sql-input {
            font-family: 'SFMono-Regular', ui-monospace, monospace;
            min-height: 120px;
        }

        .empty-state {
            text-align: center;
            padding: 2rem 1rem;
            color: var(--text-muted);
        }

        .pill {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.25rem 0.65rem;
            border-radius: 999px;
            background: rgba(148, 163, 184, 0.18);
            font-size: 0.75rem;
        }

        .divider {
            height: 1px;
            background: var(--border);
            margin: 1.25rem 0;
        }

        .info-callout {
            background: rgba(37, 99, 235, 0.08);
            color: #1d4ed8;
            border-radius: 12px;
            padding: 0.75rem 1rem;
            font-size: 0.85rem;
            border: 1px solid rgba(37, 99, 235, 0.18);
        }

        dialog {
            border: none;
            border-radius: 18px;
            box-shadow: 0 20px 50px rgba(15, 23, 42, 0.35);
            padding: 1.5rem;
            max-width: 520px;
            width: 100%;
        }

        dialog::backdrop {
            background: rgba(15, 23, 42, 0.45);
        }

        .dialog-actions {
            margin-top: 1.25rem;
            display: flex;
            justify-content: flex-end;
            gap: 0.5rem;
        }
    </style>
</head>
<body>
    <header>
        <h1>IndexedDB Workbench</h1>
        <p style="margin: 0.4rem 0 0; max-width: 720px; font-size: 0.9rem; opacity: 0.85;">Inspect, query, and manage IndexedDB databases directly in your browser. Open an existing database or create a new one, then explore object stores, run SQL-like filters, and edit records with ease.</p>
    </header>
    <main>
        <section class="panel" id="sidebar">
            <div class="section">
                <h2>Databases <span class="badge" id="db-count">0</span></h2>
                <p class="muted">Detected databases (if your browser exposes them). Select one to inspect, or open by name below.</p>
                <ul class="db-list" id="databaseList"></ul>
            </div>
            <div class="divider"></div>
            <div class="section">
                <h3>Open or Create</h3>
                <label for="dbName">Database Name</label>
                <input id="dbName" placeholder="e.g. my-app-db">
                <label for="dbVersion" style="margin-top:0.75rem;">Version <span class="pill">optional</span></label>
                <input id="dbVersion" type="number" min="1" placeholder="auto">
                <div class="actions">
                    <button class="primary" id="openDbBtn">Open database</button>
                    <button class="secondary" id="refreshDbsBtn">Refresh list</button>
                </div>
                <div class="info-callout" style="margin-top:1rem;">
                    <strong>Tip:</strong> Creating new object stores requires a version bump. Use the form below to add stores.
                </div>
            </div>
            <div class="divider"></div>
            <div class="section">
                <h3>Create Object Store</h3>
                <label for="storeName">Store Name</label>
                <input id="storeName" placeholder="e.g. users">
                <label for="storeKeyPath" style="margin-top:0.75rem;">Key Path <span class="pill">optional</span></label>
                <input id="storeKeyPath" placeholder="id">
                <div class="flex" style="align-items:center;margin-top:0.5rem;">
                    <label style="flex:initial;display:flex;align-items:center;gap:0.5rem;font-weight:500;font-size:0.85rem;">
                        <input type="checkbox" id="storeAutoIncrement" style="width:auto;"> Auto increment
                    </label>
                </div>
                <div class="actions">
                    <button class="secondary" id="createStoreBtn">Add store</button>
                </div>
                <p class="muted" style="margin-top:0.75rem;">Adding a store bumps the database version automatically. Existing data remains available.</p>
            </div>
        </section>
        <section class="panel" id="content">
            <div class="section">
                <h2>Object Stores <span class="badge" id="store-count">0</span></h2>
                <p class="muted">Select a store to view its records and structure.</p>
                <ul class="store-list" id="storeList"></ul>
                <div id="storeMeta" class="json-block" style="display:none;margin-top:1rem;"></div>
            </div>
            <div class="divider"></div>
            <div class="section" id="querySection">
                <h2>Data Explorer</h2>
                <div class="info-callout">
                    Run SQL-like queries on the loaded records. Use <code>SELECT * FROM records</code> by default. Fields are accessible by their property names, plus a <code>key</code> column for the record key.
                </div>
                <label for="sqlInput" style="margin-top:1rem;">SQL Query</label>
                <textarea id="sqlInput" class="sql-input" placeholder="SELECT * FROM records"></textarea>
                <div class="actions">
                    <button class="primary" id="runQueryBtn">Run query</button>
                    <button class="secondary" id="resetQueryBtn">Reset</button>
                </div>
                <div class="flex" style="margin-top:1rem;">
                    <div>
                        <label for="searchInput">Quick Search</label>
                        <input id="searchInput" placeholder="Search in records">
                    </div>
                    <div>
                        <label for="limitInput">Limit</label>
                        <input id="limitInput" type="number" min="1" placeholder="No limit">
                    </div>
                </div>
                <div class="actions" style="margin-top:1rem;">
                    <button class="secondary" id="exportJsonBtn">Export JSON</button>
                    <button class="secondary" id="exportCsvBtn">Export CSV</button>
                </div>
                <div class="table-container" id="tableContainer" style="display:none;"></div>
                <div class="empty-state" id="emptyState">No records loaded. Choose an object store to explore.</div>
            </div>
            <div class="divider"></div>
            <div class="section">
                <h2>Edit Record</h2>
                <div class="flex vertical">
                    <div>
                        <label for="recordKey">Key</label>
                        <input id="recordKey" placeholder="Optional if keyPath is used">
                    </div>
                    <div>
                        <label for="recordValue">Value (JSON)</label>
                        <textarea id="recordValue" rows="6" placeholder='{"id":1,"name":"Ada"}'></textarea>
                    </div>
                </div>
                <div class="actions">
                    <button class="primary" id="upsertBtn">Insert / Update</button>
                    <button class="danger" id="deleteBtn">Delete</button>
                    <button class="secondary" id="clearFormBtn">Clear form</button>
                </div>
            </div>
        </section>
    </main>
    <div class="toast-container" id="toastContainer"></div>

    <dialog id="confirmDialog">
        <h3 style="margin-top:0;">Delete Record</h3>
        <p id="confirmMessage">Are you sure you want to delete this record?</p>
        <div class="dialog-actions">
            <button class="secondary" id="cancelDeleteBtn">Cancel</button>
            <button class="danger" id="confirmDeleteBtn">Delete</button>
        </div>
    </dialog>

    <script>
        const state = {
            databases: [],
            currentDbName: null,
            db: null,
            stores: [],
            selectedStore: null,
            records: [],
            rawRecords: [],
            recordIndex: new Map(),
            queryBaseRecords: [],
            filteredRecords: [],
            pendingDeleteKey: null,
        };

        const databaseListEl = document.getElementById('databaseList');
        const storeListEl = document.getElementById('storeList');
        const storeMetaEl = document.getElementById('storeMeta');
        const dbCountEl = document.getElementById('db-count');
        const storeCountEl = document.getElementById('store-count');
        const tableContainerEl = document.getElementById('tableContainer');
        const emptyStateEl = document.getElementById('emptyState');
        const sqlInputEl = document.getElementById('sqlInput');
        const searchInputEl = document.getElementById('searchInput');
        const limitInputEl = document.getElementById('limitInput');
        const recordKeyEl = document.getElementById('recordKey');
        const recordValueEl = document.getElementById('recordValue');
        const toastContainer = document.getElementById('toastContainer');
        const confirmDialog = document.getElementById('confirmDialog');
        const confirmMessage = document.getElementById('confirmMessage');

        async function init() {
            if (!('indexedDB' in window)) {
                showToast('IndexedDB is not supported in this browser.', 'error');
                return;
            }
            await refreshDatabaseList();
            attachEventListeners();
        }

        function attachEventListeners() {
            document.getElementById('openDbBtn').addEventListener('click', openDatabaseFromForm);
            document.getElementById('refreshDbsBtn').addEventListener('click', refreshDatabaseList);
            document.getElementById('createStoreBtn').addEventListener('click', createObjectStore);
            document.getElementById('runQueryBtn').addEventListener('click', runSqlQuery);
            document.getElementById('resetQueryBtn').addEventListener('click', resetQuery);
            document.getElementById('exportJsonBtn').addEventListener('click', () => exportData('json'));
            document.getElementById('exportCsvBtn').addEventListener('click', () => exportData('csv'));
            document.getElementById('upsertBtn').addEventListener('click', upsertRecord);
            document.getElementById('deleteBtn').addEventListener('click', promptDeleteRecord);
            document.getElementById('clearFormBtn').addEventListener('click', clearRecordForm);
            searchInputEl.addEventListener('input', applyFilters);
            limitInputEl.addEventListener('input', applyFilters);
            document.getElementById('cancelDeleteBtn').addEventListener('click', () => confirmDialog.close());
            document.getElementById('confirmDeleteBtn').addEventListener('click', confirmDeleteRecord);
        }

        async function refreshDatabaseList() {
            if (!indexedDB.databases) {
                dbCountEl.textContent = 'n/a';
                databaseListEl.innerHTML = '<li class="muted" style="cursor:default;">Browser does not expose database enumeration.</li>';
                return;
            }
            try {
                const dbs = await indexedDB.databases();
                state.databases = dbs;
                dbCountEl.textContent = dbs.length;
                databaseListEl.innerHTML = '';
                dbs.forEach(dbInfo => {
                    const li = document.createElement('li');
                    li.textContent = `${dbInfo.name} (v${dbInfo.version || 'n/a'})`;
                    li.dataset.name = dbInfo.name;
                    if (dbInfo.name === state.currentDbName) {
                        li.classList.add('active');
                    }
                    li.addEventListener('click', () => {
                        document.getElementById('dbName').value = dbInfo.name;
                        document.getElementById('dbVersion').value = dbInfo.version || '';
                        openDatabase(dbInfo.name, dbInfo.version);
                    });
                    databaseListEl.appendChild(li);
                });
                if (!dbs.length) {
                    const li = document.createElement('li');
                    li.textContent = 'No databases detected. Create one below.';
                    li.classList.add('muted');
                    li.style.cursor = 'default';
                    databaseListEl.appendChild(li);
                }
            } catch (error) {
                console.error(error);
                showToast('Failed to list databases. Some browsers restrict access.', 'error');
            }
        }

        function openDatabaseFromForm() {
            const name = document.getElementById('dbName').value.trim();
            const versionValue = document.getElementById('dbVersion').value;
            if (!name) {
                showToast('Provide a database name to open.', 'error');
                return;
            }
            const version = versionValue ? Number(versionValue) : undefined;
            openDatabase(name, version);
        }

        function openDatabase(name, version) {
            if (state.db) {
                state.db.close();
            }
            const request = version ? indexedDB.open(name, version) : indexedDB.open(name);
            request.onerror = () => {
                console.error(request.error);
                showToast(`Failed to open database: ${request.error?.message || 'Unknown error'}`, 'error');
            };
            request.onsuccess = () => {
                state.db = request.result;
                state.currentDbName = name;
                renderDatabaseList();
                renderStores();
                showToast(`Opened database "${name}"`, 'success');
                state.db.onversionchange = () => {
                    showToast('Database version changed elsewhere; reloading.', 'warning');
                    state.db.close();
                };
            };
            request.onupgradeneeded = event => {
                state.db = event.target.result;
                state.currentDbName = name;
                renderDatabaseList();
                renderStores();
                showToast(`Database upgraded to version ${state.db.version}`, 'info');
            };
        }

        function renderDatabaseList() {
            Array.from(databaseListEl.children).forEach(child => {
                if (child.dataset?.name) {
                    child.classList.toggle('active', child.dataset.name === state.currentDbName);
                }
            });
        }

        function renderStores() {
            storeListEl.innerHTML = '';
            storeMetaEl.style.display = 'none';
            storeCountEl.textContent = '0';
            state.records = [];
            state.rawRecords = [];
            state.recordIndex = new Map();
            state.queryBaseRecords = [];
            state.filteredRecords = [];
            renderTable();
            if (!state.db) {
                return;
            }
            const objectStoreNames = Array.from(state.db.objectStoreNames);
            storeCountEl.textContent = objectStoreNames.length;
            if (!objectStoreNames.length) {
                const li = document.createElement('li');
                li.textContent = 'No object stores. Create one from the sidebar.';
                li.classList.add('muted');
                li.style.cursor = 'default';
                storeListEl.appendChild(li);
                return;
            }
            objectStoreNames.forEach(name => {
                const li = document.createElement('li');
                li.textContent = name;
                if (name === state.selectedStore) {
                    li.classList.add('active');
                }
                li.addEventListener('click', () => selectStore(name));
                storeListEl.appendChild(li);
            });
        }

        function selectStore(storeName) {
            state.selectedStore = storeName;
            Array.from(storeListEl.children).forEach(li => {
                li.classList.toggle('active', li.textContent === storeName);
            });
            if (!state.db) return;
            const tx = state.db.transaction(storeName, 'readonly');
            const store = tx.objectStore(storeName);
            const meta = {
                name: storeName,
                keyPath: store.keyPath,
                autoIncrement: store.autoIncrement,
                indexes: Array.from(store.indexNames).map(indexName => {
                    const index = store.index(indexName);
                    return {
                        name: index.name,
                        keyPath: index.keyPath,
                        unique: index.unique,
                        multiEntry: index.multiEntry,
                    };
                })
            };
            storeMetaEl.style.display = 'block';
            storeMetaEl.textContent = JSON.stringify(meta, null, 2);
            loadRecords(storeName);
        }

        function loadRecords(storeName) {
            if (!state.db) return;
            const tx = state.db.transaction(storeName, 'readonly');
            const store = tx.objectStore(storeName);
            const getAllRequest = store.getAll();
            const getAllKeysRequest = store.getAllKeys();

            getAllRequest.onsuccess = () => {
                const values = getAllRequest.result;
                getAllKeysRequest.onsuccess = () => {
                    const keys = getAllKeysRequest.result;
                    state.recordIndex = new Map();
                    state.rawRecords = values.map((value, index) => {
                        const entry = { key: keys[index], value };
                        state.recordIndex.set(stringifyKey(entry.key), entry);
                        return entry;
                    });
                    state.records = state.rawRecords.map(entry => normalizeRecord(entry.value, entry.key));
                    state.queryBaseRecords = [...state.records];
                    sqlInputEl.value = 'SELECT * FROM records';
                    searchInputEl.value = '';
                    limitInputEl.value = '';
                    applyFilters();
                };
            };
            getAllRequest.onerror = () => {
                console.error(getAllRequest.error);
                showToast('Failed to load records.', 'error');
            };
        }

        function normalizeRecord(value, key) {
            if (value && typeof value === 'object' && !Array.isArray(value)) {
                return { key, ...value };
            }
            return { key, value };
        }

        function renderTable() {
            if (!state.filteredRecords.length) {
                tableContainerEl.style.display = 'none';
                emptyStateEl.style.display = 'block';
                emptyStateEl.textContent = state.selectedStore ? 'No records match your filters.' : 'No records loaded. Choose an object store to explore.';
                return;
            }
            emptyStateEl.style.display = 'none';
            tableContainerEl.style.display = 'block';

            const columns = new Set(['key']);
            state.filteredRecords.forEach(record => {
                Object.keys(record).forEach(key => columns.add(key));
            });
            const columnNames = Array.from(columns);

            const table = document.createElement('table');
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            columnNames.forEach(col => {
                const th = document.createElement('th');
                th.textContent = col;
                headerRow.appendChild(th);
            });
            const actionTh = document.createElement('th');
            actionTh.textContent = 'Actions';
            headerRow.appendChild(actionTh);
            thead.appendChild(headerRow);
            table.appendChild(thead);

            const tbody = document.createElement('tbody');
            state.filteredRecords.forEach(record => {
                const row = document.createElement('tr');
                columnNames.forEach(col => {
                    const td = document.createElement('td');
                    const value = record[col];
                    td.textContent = typeof value === 'object' ? JSON.stringify(value) : value;
                    row.appendChild(td);
                });
                const actionsTd = document.createElement('td');
                const editBtn = document.createElement('button');
                editBtn.textContent = 'Edit';
                editBtn.className = 'secondary';
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Delete';
                deleteBtn.className = 'danger';
                deleteBtn.style.marginLeft = '0.5rem';
                if (record.key === undefined) {
                    editBtn.disabled = true;
                    deleteBtn.disabled = true;
                    editBtn.title = 'Include the record key in your query to edit.';
                    deleteBtn.title = 'Include the record key in your query to delete.';
                } else {
                    editBtn.addEventListener('click', () => populateForm(record));
                    deleteBtn.addEventListener('click', () => promptDelete(record.key));
                }
                actionsTd.appendChild(editBtn);
                actionsTd.appendChild(deleteBtn);
                row.appendChild(actionsTd);
                tbody.appendChild(row);
            });
            table.appendChild(tbody);
            tableContainerEl.innerHTML = '';
            tableContainerEl.appendChild(table);
        }

        function populateForm(record) {
            if (record.key === undefined) {
                showToast('Include the record key in your query to enable editing.', 'error');
                return;
            }
            const keyString = stringifyKey(record.key);
            recordKeyEl.value = keyString;
            const original = state.recordIndex.get(keyString);
            if (original) {
                try {
                    recordValueEl.value = JSON.stringify(original.value, null, 2);
                } catch (error) {
                    console.error(error);
                    showToast('Record value could not be stringified. It may contain unsupported data types.', 'error');
                    recordValueEl.value = '';
                }
                return;
            }
            const { key, ...value } = record;
            const json = Object.keys(value).length === 1 && value.value !== undefined ? value.value : value;
            recordValueEl.value = JSON.stringify(json, null, 2);
        }

        function promptDeleteRecord() {
            if (!state.selectedStore) {
                showToast('Select an object store first.', 'error');
                return;
            }
            const key = recordKeyEl.value;
            if (key === '') {
                showToast('Provide the key of the record you want to delete.', 'error');
                return;
            }
            promptDelete(parseKey(key));
        }

        function promptDelete(key) {
            state.pendingDeleteKey = key;
            confirmMessage.textContent = `Delete record with key "${stringifyKey(key)}"?`;
            confirmDialog.showModal();
        }

        function confirmDeleteRecord() {
            if (!state.selectedStore || state.pendingDeleteKey === null) {
                confirmDialog.close();
                return;
            }
            deleteRecord(state.pendingDeleteKey);
            state.pendingDeleteKey = null;
            confirmDialog.close();
        }

        function deleteRecord(key) {
            const tx = state.db.transaction(state.selectedStore, 'readwrite');
            const store = tx.objectStore(state.selectedStore);
            const request = store.delete(key);
            request.onsuccess = () => {
                showToast('Record deleted.', 'success');
                clearRecordForm();
                loadRecords(state.selectedStore);
            };
            request.onerror = () => {
                console.error(request.error);
                showToast('Failed to delete record.', 'error');
            };
        }

        function upsertRecord() {
            if (!state.selectedStore) {
                showToast('Select an object store first.', 'error');
                return;
            }
            let value;
            try {
                value = recordValueEl.value ? JSON.parse(recordValueEl.value) : {};
            } catch (error) {
                showToast('Value must be valid JSON.', 'error');
                return;
            }
            const keyInput = recordKeyEl.value;
            const tx = state.db.transaction(state.selectedStore, 'readwrite');
            const store = tx.objectStore(state.selectedStore);
            let request;
            if (store.keyPath) {
                request = store.put(value);
            } else if (keyInput) {
                request = store.put(value, parseKey(keyInput));
            } else {
                showToast('This store requires an explicit key value.', 'error');
                return;
            }
            request.onsuccess = () => {
                showToast('Record saved.', 'success');
                clearRecordForm();
                loadRecords(state.selectedStore);
            };
            request.onerror = () => {
                console.error(request.error);
                showToast(`Failed to save record: ${request.error?.message || 'Unknown error'}`, 'error');
            };
        }

        function parseKey(key) {
            if (key === '') return key;
            try {
                return JSON.parse(key);
            } catch {
                return key;
            }
        }

        function stringifyKey(key) {
            if (key === undefined || key === null) return '';
            if (typeof key === 'object') {
                try {
                    return JSON.stringify(key);
                } catch {
                    return String(key);
                }
            }
            return String(key);
        }

        function clearRecordForm() {
            recordKeyEl.value = '';
            recordValueEl.value = '';
        }

        function applyFilters() {
            const base = Array.isArray(state.queryBaseRecords) ? state.queryBaseRecords : state.records;
            let records = [...base];
            const searchTerm = searchInputEl.value.trim().toLowerCase();
            if (searchTerm) {
                records = records.filter(record => JSON.stringify(record).toLowerCase().includes(searchTerm));
            }
            const limitValue = Number(limitInputEl.value);
            if (limitValue > 0) {
                records = records.slice(0, limitValue);
            }
            state.filteredRecords = records;
            renderTable();
        }

        function runSqlQuery() {
            if (!state.records.length) {
                showToast('No records loaded.', 'error');
                return;
            }
            const query = sqlInputEl.value.trim() || 'SELECT * FROM records';
            try {
                const result = alasql(query, [state.records]);
                if (!Array.isArray(result)) {
                    showToast('Query executed. See console for result.', 'info');
                    console.log(result);
                    return;
                }
                state.queryBaseRecords = result.map(record => (
                    record && typeof record === 'object'
                        ? { ...record }
                        : { value: record }
                ));
                applyFilters();
                showToast('Query executed.', 'success');
            } catch (error) {
                console.error(error);
                showToast(`Query error: ${error.message}`, 'error');
            }
        }

        function resetQuery() {
            sqlInputEl.value = 'SELECT * FROM records';
            searchInputEl.value = '';
            limitInputEl.value = '';
            state.queryBaseRecords = [...state.records];
            applyFilters();
        }

        function exportData(format) {
            if (!state.filteredRecords.length) {
                showToast('No data to export.', 'error');
                return;
            }
            let content;
            let filename;
            if (format === 'json') {
                content = JSON.stringify(state.filteredRecords, null, 2);
                filename = `${state.selectedStore || 'records'}.json`;
                downloadFile(content, filename, 'application/json');
            } else if (format === 'csv') {
                const columns = Array.from(new Set(state.filteredRecords.flatMap(record => Object.keys(record))));
                const csvRows = [columns.join(',')];
                state.filteredRecords.forEach(record => {
                    const row = columns.map(column => escapeCsvValue(record[column]));
                    csvRows.push(row.join(','));
                });
                content = csvRows.join('\n');
                filename = `${state.selectedStore || 'records'}.csv`;
                downloadFile(content, filename, 'text/csv');
            }
            showToast(`Exported ${format.toUpperCase()} file.`, 'success');
        }

        function escapeCsvValue(value) {
            if (value === null || value === undefined) return '';
            const stringValue = typeof value === 'object' ? JSON.stringify(value) : String(value);
            if (stringValue.includes(',') || stringValue.includes('"') || stringValue.includes('\n')) {
                return '"' + stringValue.replace(/"/g, '""') + '"';
            }
            return stringValue;
        }

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function createObjectStore() {
            if (!state.currentDbName) {
                showToast('Open a database first.', 'error');
                return;
            }
            const name = document.getElementById('storeName').value.trim();
            const keyPath = document.getElementById('storeKeyPath').value.trim();
            const autoIncrement = document.getElementById('storeAutoIncrement').checked;
            if (!name) {
                showToast('Store name is required.', 'error');
                return;
            }
            const newVersion = (state.db?.version || 0) + 1;
            state.db.close();
            const request = indexedDB.open(state.currentDbName, newVersion);
            request.onupgradeneeded = event => {
                const db = event.target.result;
                const options = {};
                if (keyPath) options.keyPath = keyPath;
                if (autoIncrement) options.autoIncrement = true;
                try {
                    db.createObjectStore(name, options);
                    showToast(`Created store "${name}" (v${db.version}).`, 'success');
                } catch (error) {
                    showToast(`Failed to create store: ${error.message}`, 'error');
                }
            };
            request.onsuccess = () => {
                state.db = request.result;
                renderStores();
                document.getElementById('storeName').value = '';
                document.getElementById('storeKeyPath').value = '';
                document.getElementById('storeAutoIncrement').checked = false;
            };
            request.onerror = () => {
                console.error(request.error);
                showToast(`Failed to upgrade database: ${request.error?.message || 'Unknown error'}`, 'error');
            };
        }

        function exportDataToClipboard() {
            navigator.clipboard.writeText(JSON.stringify(state.filteredRecords, null, 2))
                .then(() => showToast('Copied to clipboard.', 'success'))
                .catch(error => {
                    console.error(error);
                    showToast('Failed to copy to clipboard.', 'error');
                });
        }

        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.innerHTML = `<span>${message}</span>`;
            const dismiss = document.createElement('button');
            dismiss.textContent = '×';
            dismiss.addEventListener('click', () => toast.remove());
            toast.appendChild(dismiss);
            toastContainer.appendChild(toast);
            setTimeout(() => {
                toast.classList.add('hide');
                toast.remove();
            }, 4000);
        }

        window.addEventListener('beforeunload', () => {
            if (state.db) {
                state.db.close();
            }
        });

        init();
    </script>
</body>
</html>
